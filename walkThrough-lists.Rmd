---
title: "Lists"
output:
  html_document:
    toc: true
    theme: united
---

```{r, echo=FALSE}
stopifnot(require(svgR, quietly=TRUE))
```

```{r, echo=FALSE}
if(!exists("newId")){
  source('Util.R')
}
```
## Lesson 1: Building with Lists


Let's start by putting down some points on our drawing area (viewPort)
First

Recall from Lesson 0, that the dimensions of the display region is determined by 
setting wh in the call to svgR, and that we can flood the display region using a feFlood filter element. So, let's flood the region and label some points

```{r, echo=T, results="asis"}
WH<-c(600,200)
coord<-expand.grid(c(30,WH[1]-30),c(20,WH[2]-20))
svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      text('Coordinates',  cxy=WH/2, font.size=30 ),
      text(paste(coord[1,],collapse=","), cxy=as.numeric(coord[1,])),
      text(paste(coord[2,],collapse=","), cxy=as.numeric(coord[2,])),
      text(paste(coord[3,],collapse=","), cxy=as.numeric(coord[3,])),
      text(paste(coord[4,],collapse=","), cxy=as.numeric(coord[4,])),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

Now that we can see the display region, we can identify a few points on it.
But the code is a little hard on the eyes, and troublesome if we had more points. So lets combine using lapply

```{r, echo=T, results="asis"}
WH<-c(600,200)
coord<-expand.grid(c(30,WH[1]-30),c(20,WH[2]-20))
svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      text('Coordinates',  cxy=WH/2, font.size=30 ),
      lapply(1:nrow(coord), function(i){
        cxy<-as.numeric(coord[i,])
        txt<-paste(cxy, collapse=",")
        text(txt, cxy=cxy)
      }),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

In svgR, unnamed arguments which are list are automatically "promoted" to become arguments of the calling function. So in our case the return of lapply is list whose results inserted in place. 

Labeling more points is a snap

```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
coord<-expand.grid(
  seq(from=dxy[1], to=WH[1]-dxy[1], by=dxy[1]),
  seq(from=dxy[2], to=WH[2]-dxy[2], by=dxy[2])
)
svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      lapply(1:nrow(coord), function(i){
        cxy<-as.numeric(coord[i,])
        txt<-paste(cxy, collapse=",")
        text(txt, cxy=cxy)
      }),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

Or just labeling the edges:

```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
xx<-seq(0,WH[1], by=dxy[1])
yy<-seq(0,WH[2], by=dxy[2])

svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      lapply(xx, function(x){ text(x,xy=c(x,10))}),
      lapply(yy, function(y){ text(y,xy=c(0,y))}),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

Now add some horzontal and vertical lines
```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
xx<-seq(0,WH[1], by=dxy[1])
yy<-seq(0,WH[2], by=dxy[2])

svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      lapply(xx, function(x){ text(x,xy=c(x,10))}),
      lapply(xx, function(x){ line(xy1=c(x,0), xy2=c(x,WH[2]), stroke='black' )} ),
      lapply(yy, function(y){ text(y,xy=c(0,y))}),
      lapply(yy, function(y){ line(xy1=c(0,y), xy2=c(WH[1],y), stroke='black')} ),
     rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

An alternative is to combine the two lapply(xx) calls and the two lapply(yy) calls. 
```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
xx<-seq(0,WH[1], by=dxy[1])
yy<-seq(0,WH[2], by=dxy[2])

svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='lightblue'))),
      lapply(xx, function(x){ 
        list(
          text(x,xy=c(x,10)), 
          line(xy1=c(x,0), xy2=c(x,WH[2]), stroke='black' ) 
        )
      }),
      lapply(yy, function(y){
        list(
          text(y,xy=c(0,y)),
          line(xy1=c(0,y), xy2=c(WH[1],y), stroke='black') 
        )
      }),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

Here Each lapply returns an list of lists. Again svgR promotes these
Another alternative is to use a group instead of a list. Grouping elements allows to treat the elements as a unit. Unlike the list, we can assign attributes to group. For example, here weassign two different stroke colors.

```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
xx<-seq(0,WH[1], by=dxy[1])
yy<-seq(0,WH[2], by=dxy[2])

svgR( wh=WH,  
      use(filter=filter( feFlood(flood.color='#DDDDFF'))),
      lapply(xx, function(x){ 
        g( stroke='red', 
          text(x,xy=c(x,10)), 
          line(xy1=c(x,0), xy2=c(x,WH[2]) ) 
        )
      }),
      lapply(yy, function(y){
        g( stroke='green', 
          text(y,xy=c(0,y)),
          line(xy1=c(0,y), xy2=c(WH[1],y), stroke.dasharray=3, stroke.width=3) 
        )
      }),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

A final thought, what happens when we zoom out. (To zoom out we change the viewBox)


```{r, echo=T, results="asis"}
WH<-c(600,200)
dxy<-c(50,30)
xx<-seq(0,WH[1], by=dxy[1])
yy<-seq(0,WH[2], by=dxy[2])

svgR( wh=WH,  viewBox=c(0,0,2*WH),
      use(filter=filter( feFlood(flood.color='#DDDDFF'))),
      lapply(xx, function(x){ 
        g( stroke='red', 
          text(x,xy=c(x,10)), 
          line(xy1=c(x,0), xy2=c(x,WH[2]) ) 
        )
      }),
      lapply(yy, function(y){
        g( stroke='green', 
          text(y,xy=c(0,y)),
          line(xy1=c(0,y), xy2=c(WH[1],y), stroke.dasharray=3, stroke.width=3) 
        )
      }),
      rect(xy=c(0,0), wh=WH, stroke.width=3, fill="none", stroke='black')
)
```

